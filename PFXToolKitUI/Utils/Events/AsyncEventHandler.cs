// 
// Copyright (c) 2025-2025 REghZy
// 
// This file is part of PFXToolKitUI.
// 
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 3 of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with PFXToolKitUI. If not, see <https://www.gnu.org/licenses/>.
// 

using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace PFXToolKitUI.Utils.Events;

/// <summary>
/// Represents the method that will asynchronously handle an event that has no event data.
/// </summary>
/// <param name="sender">The source of the event.</param>
/// <param name="e">An object that contains no event data.</param>
public delegate Task AsyncEventHandler(object? sender, EventArgs e);

/// <summary>
/// Represents the method that will asynchronously handle an event that provides data.
/// </summary>
/// <param name="sender">The source of the event.</param>
/// <param name="e">An object that contains event data.</param>
/// <returns>A task that completes when the handler has finished</returns>
/// <typeparam name="TEventArgs">The type of the event data generated by the event</typeparam>
public delegate Task AsyncEventHandler<in TEventArgs>(object? sender, TEventArgs e);

/// <summary>
/// Represents the method that will asynchronously handle an event that provides data.
/// </summary>
/// <param name="sender">The source of the event.</param>
/// <param name="e">An object that contains event data.</param>
/// <returns>A task that completes when the handler has finished</returns>
/// <typeparam name="TSender">The type of the object raising the event</typeparam>
/// <typeparam name="TEventArgs">The type of the event data generated by the event</typeparam>
public delegate Task AsyncEventHandler<in TSender, in TEventArgs>(TSender sender, TEventArgs e);

/// <summary>
/// Represents the method that invokes an async event handler
/// </summary>
public delegate Task AsyncInvocationStrategy(AsyncEventHandler handler, object? sender, EventArgs e);

/// <summary>
/// Represents the method that invokes an async event handler
/// </summary>
/// <typeparam name="TEventHandler">The type of event handler</typeparam>
/// <typeparam name="TEventArgs">The type of event args</typeparam>
public delegate Task AsyncInvocationStrategy<in TEventHandler, TEventArgs>(AsyncEventHandler<TEventArgs> handler, object? sender, TEventArgs e);

/// <summary>
/// Represents the method that invokes an async event handler
/// </summary>
/// <typeparam name="TEventHandler">The type of event handler</typeparam>
/// <typeparam name="TSender">The type of sender</typeparam>
/// <typeparam name="TEventArgs">The type of event args</typeparam>
public delegate Task AsyncInvocationStrategy<in TEventHandler, TSender, TEventArgs>(AsyncEventHandler<TSender, TEventArgs> handler, TSender sender, TEventArgs e);

public static class AsyncEventUtils {
    private delegate Task InternalInvocationStrategy(Delegate handler, object? sender, object? args, object? state);

    /// <summary>
    /// Invokes every event handler and asynchronously waits for their returned tasks to complete.
    /// </summary>
    /// <param name="handler">The delegate whose invocation list should be invoked</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="args">The args to pass to each handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <param name="invocationStrategy">
    /// A callback for invoking each specific handler. The default is null, meaning each handler is invoked using <see cref="Task.Run(Func{Task?})"/>
    /// </param>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeAsync(this AsyncEventHandler? handler, object? sender, EventArgs args, bool ignoreCancelled = true, AsyncInvocationStrategy? invocationStrategy = null) {
        Delegate[]? list = handler?.GetInvocationList();
        if (list == null || list.Length < 1) {
            return Task.CompletedTask;
        }

        return InternalInvokeAsync(sender, args, invocationStrategy ?? (static (h, s, e) => Task.Run(() => h(s, e))), list, InvokeAsyncImpl, ignoreCancelled);

        static Task InvokeAsyncImpl(Delegate handler, object? _sender, object? _args, object? _state) {
            return ((AsyncInvocationStrategy) _state!)((AsyncEventHandler) handler, _sender, (EventArgs) _args!);
        }
    }

    /// <summary>
    /// Invokes every event handler and asynchronously waits for their returned tasks to complete.
    /// </summary>
    /// <param name="handler">The delegate whose invocation list should be invoked</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="args">The args to pass to each handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <param name="invocationStrategy">
    /// A callback for invoking each specific handler. The default is null, meaning each handler is invoked using <see cref="Task.Run(Func{Task?})"/>
    /// </param>
    /// <typeparam name="TEventArgs">The type of event args passed to the handlers</typeparam>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeAsync<TEventArgs>(this AsyncEventHandler<TEventArgs>? handler, object? sender, TEventArgs args, bool ignoreCancelled = true, AsyncInvocationStrategy<AsyncEventHandler<TEventArgs>, TEventArgs>? invocationStrategy = null) {
        Delegate[]? list = handler?.GetInvocationList();
        if (list == null || list.Length < 1) {
            return Task.CompletedTask;
        }

        return InternalInvokeAsync(sender, args, invocationStrategy ?? (static (h, s, e) => Task.Run(() => h(s, e))), list, InvokeAsyncWithArgsImpl, ignoreCancelled);

        static Task InvokeAsyncWithArgsImpl(Delegate handler, object? _sender, object? _args, object? _state) {
            return ((AsyncInvocationStrategy<AsyncEventHandler<TEventArgs>, TEventArgs>) _state!)((AsyncEventHandler<TEventArgs>) handler, _sender, (TEventArgs) _args!);
        }
    }

    /// <summary>
    /// Invokes every event handler and asynchronously waits for their returned tasks to complete.
    /// </summary>
    /// <param name="handler">The delegate whose invocation list should be invoked</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="args">The args to pass to each handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <param name="invocationStrategy">
    /// A callback for invoking each specific handler. The default is null, meaning each handler is invoked using <see cref="Task.Run(Func{Task?})"/>
    /// </param>
    /// <typeparam name="TSender">The type of sender parameter</typeparam>
    /// <typeparam name="TEventArgs">The type of event args passed to the handlers</typeparam>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeAsync<TSender, TEventArgs>(this AsyncEventHandler<TSender, TEventArgs>? handler, TSender sender, TEventArgs args, bool ignoreCancelled = true, AsyncInvocationStrategy<AsyncEventHandler<TSender, TEventArgs>, TSender, TEventArgs>? invocationStrategy = null) {
        Delegate[]? list = handler?.GetInvocationList();
        if (list == null || list.Length < 1) {
            return Task.CompletedTask;
        }

        return InternalInvokeAsync(sender, args, invocationStrategy ?? (static (h, s, e) => Task.Run(() => h(s, e))), list, InvokeAsyncWithSenderAndArgsImpl, ignoreCancelled);

        static Task InvokeAsyncWithSenderAndArgsImpl(Delegate handler, object? _sender, object? _args, object? _state) {
            return ((AsyncInvocationStrategy<AsyncEventHandler<TSender, TEventArgs>, TSender, TEventArgs>) _state!)((AsyncEventHandler<TSender, TEventArgs>) handler, (TSender) _sender!, (TEventArgs) _args!);
        }
    }

    /// <summary>
    /// Invokes every event handler and asynchronously waits for their returned tasks to complete. Invokes a factory method (in the invocation strategy callback) to generate new args for each handler.
    /// </summary>
    /// <param name="handler">The delegate whose invocation list should be invoked</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="argsFactory">A factory that produces new args for each handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <param name="invocationStrategy">
    /// A callback for invoking each specific handler. The default is null, meaning each handler is invoked using <see cref="Task.Run(Func{Task?})"/>
    /// </param>
    /// <typeparam name="TEventArgs">The type of event args passed to the handlers</typeparam>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeWithFactoryArgsAsync<TEventArgs>(this AsyncEventHandler<TEventArgs>? handler, object? sender, Func<object?, TEventArgs> argsFactory, bool ignoreCancelled = true, AsyncInvocationStrategy<AsyncEventHandler<TEventArgs>, object?, TEventArgs>? invocationStrategy = null) {
        Delegate[]? list = handler?.GetInvocationList();
        if (list == null || list.Length < 1) {
            return Task.CompletedTask;
        }

        return InternalInvokeAsync(sender, argsFactory, invocationStrategy ?? (static (h, s, e) => Task.Run(() => h(s, e))), list, InvokeAsyncImpl, ignoreCancelled);

        static Task InvokeAsyncImpl(Delegate handler, object? _sender, object? _argsFactory, object? _state) {
            TEventArgs args = ((Func<object?, TEventArgs>) _argsFactory!)(_sender);
            return ((AsyncInvocationStrategy<AsyncEventHandler<TEventArgs>, TEventArgs>) _state!)((AsyncEventHandler<TEventArgs>) handler, _sender, args);
        }
    }

    /// <summary>
    /// Invokes every event handler and asynchronously waits for their returned tasks to complete. Invokes a factory method (in the invocation strategy callback) to generate new args for each handler.
    /// </summary>
    /// <param name="handler">The delegate whose invocation list should be invoked</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="argsFactory">A factory that produces new args for each handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <param name="invocationStrategy">
    /// A callback for invoking each specific handler. The default is null, meaning each handler is invoked using <see cref="Task.Run(Func{Task?})"/>
    /// </param>
    /// <typeparam name="TSender">The type of sender parameter</typeparam>
    /// <typeparam name="TEventArgs">The type of event args passed to the handlers</typeparam>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeWithFactoryArgsAsync<TSender, TEventArgs>(this AsyncEventHandler<TSender, TEventArgs>? handler, TSender sender, Func<TSender, TEventArgs> argsFactory, bool ignoreCancelled = true, AsyncInvocationStrategy<AsyncEventHandler<TSender, TEventArgs>, TSender, TEventArgs>? invocationStrategy = null) {
        Delegate[]? list = handler?.GetInvocationList();
        if (list == null || list.Length < 1) {
            return Task.CompletedTask;
        }

        return InternalInvokeAsync(sender, argsFactory, invocationStrategy ?? (static (h, s, e) => Task.Run(() => h(s, e))), list, InvokeAsyncImpl, ignoreCancelled);

        static Task InvokeAsyncImpl(Delegate handler, object? _sender, object? _argsFactory, object? _state) {
            TEventArgs args = ((Func<TSender, TEventArgs>) _argsFactory!)((TSender) _sender!);
            return ((AsyncInvocationStrategy<AsyncEventHandler<TSender, TEventArgs>, TSender, TEventArgs>) _state!)((AsyncEventHandler<TSender, TEventArgs>) handler, (TSender) _sender!, args);
        }
    }

    private static async Task InternalInvokeAsync(object? sender, object? args, object? state, Delegate[] handlers, InternalInvocationStrategy invocationStrategy, bool ignoreCancelled) {
        Task[] tasks = new Task[handlers.Length];
        for (int i = 0; i < handlers.Length; i++) {
            tasks[i] = invocationStrategy(handlers[i], sender, args, state);
        }

        await Task.WhenAll(tasks);

        List<Exception>? exceptions = null;
        foreach (Task task in tasks) {
            Debug.Assert(task.IsCompleted, "Expected task to be completed because of Task.WhenAll");

            try {
                task.GetAwaiter().GetResult();
            }
            catch (OperationCanceledException) when (ignoreCancelled) {
                // ignored
            }
            catch (Exception e) {
                (exceptions ??= []).Add(e);
            }
        }

        if (exceptions != null) {
            Debug.Assert(exceptions.Count > 0);
            ThrowForExceptions(exceptions);
        }

        return;

        [DoesNotReturn]
        [MethodImpl(MethodImplOptions.NoInlining)]
        static void ThrowForExceptions(List<Exception> list) {
            throw new AggregateException("One or more exceptions occurred while invoking handlers", list);
        }
    }
}