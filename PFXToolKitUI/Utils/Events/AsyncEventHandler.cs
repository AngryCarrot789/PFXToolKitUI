// 
// Copyright (c) 2025-2025 REghZy
// 
// This file is part of PFXToolKitUI.
// 
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 3 of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with PFXToolKitUI. If not, see <https://www.gnu.org/licenses/>.
// 

using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace PFXToolKitUI.Utils.Events;

/// <summary>
/// Represents the method that will asynchronously handle an event that has no event data.
/// </summary>
/// <param name="sender">The source of the event.</param>
/// <param name="e">An object that contains no event data.</param>
public delegate Task AsyncEventHandler(object? sender, EventArgs e);

/// <summary>
/// Represents the method that will asynchronously handle an event that provides data.
/// </summary>
/// <param name="sender">The source of the event.</param>
/// <param name="e">An object that contains event data.</param>
/// <returns>A task that completes when the handler has finished</returns>
/// <typeparam name="TEventArgs">The type of the event data generated by the event</typeparam>
public delegate Task AsyncEventHandler<in TEventArgs>(object? sender, TEventArgs e);

/// <summary>
/// Represents the method that will asynchronously handle an event that provides data.
/// </summary>
/// <param name="sender">The source of the event.</param>
/// <param name="e">An object that contains event data.</param>
/// <returns>A task that completes when the handler has finished</returns>
/// <typeparam name="TSender">The type of the object raising the event</typeparam>
/// <typeparam name="TEventArgs">The type of the event data generated by the event</typeparam>
public delegate Task AsyncEventHandler<in TSender, in TEventArgs>(TSender sender, TEventArgs e);

public static class AsyncEventUtils {
    private delegate Task InvokeHandlerAsync(Delegate handler, object? sender, object? args, object? state);
    
    /// <summary>
    /// Asynchronously invokes the given async event handler's invocation list
    /// </summary>
    /// <param name="handler">The handler to invoke (including invocation list)</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="args">The args to pass to each handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeAsync(AsyncEventHandler? handler, object? sender, EventArgs args, bool ignoreCancelled = true) {
        Delegate[]? list = handler?.GetInvocationList();
        return list == null || list.Length < 1 ? Task.CompletedTask : InternalInvokeAsync(sender, args, null, list, InvokeAsyncImpl, ignoreCancelled);

        static Task InvokeAsyncImpl(Delegate handler, object? _sender, object? _args, object? _) {
            return Task.Run(() => ((AsyncEventHandler) handler)(_sender, (EventArgs) _args!));
        }
    }

    /// <summary>
    /// Asynchronously invokes the given async event handler's invocation list
    /// </summary>
    /// <param name="handler">The handler to invoke (including invocation list)</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="args">The args to pass to each handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <typeparam name="TEventArgs">The type of event args passed to the handlers</typeparam>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeAsync<TEventArgs>(AsyncEventHandler<TEventArgs>? handler, object? sender, TEventArgs args, bool ignoreCancelled = true) {
        Delegate[]? list = handler?.GetInvocationList();
        return list == null || list.Length < 1 ? Task.CompletedTask : InternalInvokeAsync(sender, args, null, list, InvokeAsyncWithArgsImpl, ignoreCancelled);

        static Task InvokeAsyncWithArgsImpl(Delegate handler, object? _sender, object? _args, object? _) {
            return Task.Run(() => ((AsyncEventHandler<TEventArgs>) handler)(_sender, (TEventArgs) _args!));
        }
    }

    /// <summary>
    /// Asynchronously invokes the given async event handler's invocation list
    /// </summary>
    /// <param name="handler">The handler to invoke (including invocation list)</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="args">The args to pass to each handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <typeparam name="TSender">The type of sender parameter</typeparam>
    /// <typeparam name="TEventArgs">The type of event args passed to the handlers</typeparam>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeAsync<TSender, TEventArgs>(AsyncEventHandler<TSender, TEventArgs>? handler, TSender sender, TEventArgs args, bool ignoreCancelled = true) {
        Delegate[]? list = handler?.GetInvocationList();
        return list == null || list.Length < 1 ? Task.CompletedTask : InternalInvokeAsync(sender, args, null, list, InvokeAsyncWithSenderAndArgsImpl, ignoreCancelled);

        static Task InvokeAsyncWithSenderAndArgsImpl(Delegate handler, object? _sender, object? _args, object? _) {
            return Task.Run(() => ((AsyncEventHandler<TSender, TEventArgs>) handler)((TSender) _sender!, (TEventArgs) _args!));
        }
    }
    
    /// <summary>
    /// Asynchronously invokes the given async event handler's invocation list using a custom defined function that produces a task for a handler
    /// </summary>
    /// <param name="handler">The handler to invoke (including invocation list)</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="args">The args to pass to each handler</param>
    /// <param name="invokeAsync">The callback that produces a task from a handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeCustomDispatchAsync(AsyncEventHandler? handler, object? sender, EventArgs args, Func<object?, EventArgs, AsyncEventHandler, Task> invokeAsync, bool ignoreCancelled = true) {
        Delegate[]? list = handler?.GetInvocationList();
        return list == null || list.Length < 1 ? Task.CompletedTask : InternalInvokeAsync(sender, args, invokeAsync, list, InvokeAsyncImpl, ignoreCancelled);

        static Task InvokeAsyncImpl(Delegate handler, object? _sender, object? _args, object? _state) {
            return ((Func<object?, EventArgs, AsyncEventHandler, Task>) _state!)(_sender, (EventArgs) _args!, (AsyncEventHandler) handler);
        }
    }
    
    /// <summary>
    /// Asynchronously invokes the given async event handler's invocation list using a custom defined function that produces a task for a handler
    /// </summary>
    /// <param name="handler">The handler to invoke (including invocation list)</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="args">The args to pass to each handler</param>
    /// <param name="invokeAsync">The callback that produces a task from a handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <typeparam name="TEventArgs">The type of event args passed to the handlers</typeparam>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeCustomDispatchAsync<TEventArgs>(AsyncEventHandler<TEventArgs>? handler, object? sender, TEventArgs args, Func<object?, TEventArgs, AsyncEventHandler<TEventArgs>, Task> invokeAsync, bool ignoreCancelled = true) {
        Delegate[]? list = handler?.GetInvocationList();
        return list == null || list.Length < 1 ? Task.CompletedTask : InternalInvokeAsync(sender, args, invokeAsync, list, InvokeAsyncImpl, ignoreCancelled);

        static Task InvokeAsyncImpl(Delegate handler, object? _sender, object? _args, object? _state) {
            return ((Func<object?, TEventArgs, AsyncEventHandler<TEventArgs>, Task>) _state!)(_sender, (TEventArgs) _args!, (AsyncEventHandler<TEventArgs>) handler);
        }
    }
    
    /// <summary>
    /// Asynchronously invokes the given async event handler's invocation list using a custom defined function that produces a task for a handler
    /// </summary>
    /// <param name="handler">The handler to invoke (including invocation list)</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="args">The args to pass to each handler</param>
    /// <param name="invokeAsync">The callback that produces a task from a handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <typeparam name="TSender">The type of sender parameter</typeparam>
    /// <typeparam name="TEventArgs">The type of event args passed to the handlers</typeparam>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeCustomDispatchAsync<TSender, TEventArgs>(AsyncEventHandler<TSender, TEventArgs>? handler, TSender? sender, TEventArgs args, Func<TSender, TEventArgs, AsyncEventHandler<TEventArgs>, Task> invokeAsync, bool ignoreCancelled = true) {
        Delegate[]? list = handler?.GetInvocationList();
        return list == null || list.Length < 1 ? Task.CompletedTask : InternalInvokeAsync(sender, args, invokeAsync, list, InvokeAsyncImpl, ignoreCancelled);

        static Task InvokeAsyncImpl(Delegate handler, object? _sender, object? _args, object? _state) {
            return ((Func<TSender, TEventArgs, AsyncEventHandler<TEventArgs>, Task>) _state!)((TSender) _sender!, (TEventArgs) _args!, (AsyncEventHandler<TEventArgs>) handler);
        }
    }
    
    /// <summary>
    /// Asynchronously invokes the given async event handler's invocation list, and calls the args factory for each
    /// handler (on the calling thread) and passes the returned value to each handler
    /// </summary>
    /// <param name="handler">The handler to invoke (including invocation list)</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="argsFactory">A factory that produces new args for each handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <typeparam name="TEventArgs">The type of event args passed to the handlers</typeparam>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeCustomArgsAsync<TEventArgs>(AsyncEventHandler<TEventArgs>? handler, object? sender, Func<object?, TEventArgs> argsFactory, bool ignoreCancelled = true) {
        Delegate[]? list = handler?.GetInvocationList();
        return list == null || list.Length < 1 ? Task.CompletedTask : InternalInvokeAsync(sender, argsFactory, null, list, InvokeAsyncImpl, ignoreCancelled);

        static Task InvokeAsyncImpl(Delegate handler, object? _sender, object? _argsFactory, object? _) {
            TEventArgs args = ((Func<object?, TEventArgs>) _argsFactory!)(_sender);
            return Task.Run(() => ((AsyncEventHandler<TEventArgs>) handler)(_sender, args));
        }
    }
    
    /// <summary>
    /// Asynchronously invokes the given async event handler's invocation list, and calls the args factory for each
    /// handler (on the calling thread) and passes the returned value to each handler
    /// </summary>
    /// <param name="handler">The handler to invoke (including invocation list)</param>
    /// <param name="sender">The sender parameter to pass to the handler(s)</param>
    /// <param name="argsFactory">A factory that produces new args for each handler</param>
    /// <param name="ignoreCancelled">True to ignore cancelled tasks, False to append them to the exception list and cause this function to throw</param>
    /// <typeparam name="TSender">The type of sender parameter</typeparam>
    /// <typeparam name="TEventArgs">The type of event args passed to the handlers</typeparam>
    /// <returns>A task that completes once all handlers have completed</returns>
    /// <exception cref="AggregateException">One or more tasks became faulted</exception>
    public static Task InvokeCustomArgsAsync<TSender, TEventArgs>(AsyncEventHandler<TSender, TEventArgs>? handler, TSender? sender, Func<TSender, TEventArgs> argsFactory, bool ignoreCancelled = true) {
        Delegate[]? list = handler?.GetInvocationList();
        return list == null || list.Length < 1 ? Task.CompletedTask : InternalInvokeAsync(sender, argsFactory, null, list, InvokeAsyncImpl, ignoreCancelled);

        static Task InvokeAsyncImpl(Delegate handler, object? _sender, object? _argsFactory, object? _) {
            TEventArgs args = ((Func<TSender, TEventArgs>) _argsFactory!)((TSender) _sender!);
            return Task.Run(() => ((AsyncEventHandler<TEventArgs>) handler)(_sender, args));
        }
    }
    
    public static Task InvokeCustomDispatchAndArgsAsync<TEventArgs>(AsyncEventHandler<TEventArgs>? handler, object? sender, Func<object?, TEventArgs> argsFactory, Func<object?, TEventArgs, AsyncEventHandler<TEventArgs>, Task> invokeAsync, bool ignoreCancelled = true) {
        Delegate[]? list = handler?.GetInvocationList();
        return list == null || list.Length < 1 ? Task.CompletedTask : InternalInvokeAsync(sender, argsFactory, invokeAsync, list, InvokeAsyncImpl, ignoreCancelled);

        static Task InvokeAsyncImpl(Delegate handler, object? _sender, object? _argsFactory, object? _dispatch) {
            return ((Func<object?, TEventArgs, AsyncEventHandler<TEventArgs>, Task>) _dispatch!)(_sender!, ((Func<object?, TEventArgs>) _argsFactory!)(_sender!), (AsyncEventHandler<TEventArgs>) handler);
        }
    }
    
    public static Task InvokeCustomDispatchAndArgsAsync<TSender, TEventArgs>(AsyncEventHandler<TSender, TEventArgs>? handler, TSender? sender, Func<TSender, TEventArgs> argsFactory, Func<TSender, TEventArgs, AsyncEventHandler<TEventArgs>, Task> invokeAsync, bool ignoreCancelled = true) {
        Delegate[]? list = handler?.GetInvocationList();
        return list == null || list.Length < 1 ? Task.CompletedTask : InternalInvokeAsync(sender, argsFactory, invokeAsync, list, InvokeAsyncImpl, ignoreCancelled);

        static Task InvokeAsyncImpl(Delegate handler, object? _sender, object? _argsFactory, object? _dispatch) {
            return ((Func<TSender, TEventArgs, AsyncEventHandler<TEventArgs>, Task>) _dispatch!)((TSender) _sender!, ((Func<TSender, TEventArgs>) _argsFactory!)((TSender) _sender!), (AsyncEventHandler<TEventArgs>) handler);
        }
    }

    private static async Task InternalInvokeAsync(object? sender, object? args, object? state, Delegate[] handlers, InvokeHandlerAsync invokeAsync, bool ignoreCancelled) {
        Task[] tasks = new Task[handlers.Length];
        for (int i = 0; i < handlers.Length; i++) {
            tasks[i] = invokeAsync(handlers[i], sender, args, state);
        }

        await Task.WhenAll(tasks);

        List<Exception>? exceptions = null;
        foreach (Task task in tasks) {
            Debug.Assert(task.IsCompleted, "Expected task to be completed because of Task.WhenAll");

            try {
                task.GetAwaiter().GetResult();
            }
            catch (OperationCanceledException) when (ignoreCancelled) {
                // ignored
            }
            catch (Exception e) {
                (exceptions ??= []).Add(e);
            }
        }

        if (exceptions != null) {
            Debug.Assert(exceptions.Count > 0);
            ThrowForExceptions(exceptions);
        }

        return;

        [DoesNotReturn]
        [MethodImpl(MethodImplOptions.NoInlining)]
        static void ThrowForExceptions(List<Exception> list) {
            throw new AggregateException("One or more exceptions occurred while invoking handlers", list);
        }
    }
}